# 한글 폰트 변환 도구

EasyView 조합형 한글 폰트 바이너리 파일(`.han`)을 Arduino/ESP32용 폰트 C 헤더 파일(`.h`)로 변환하는 도구 제작 레퍼런스

---

## 1. 폰트 구조

### 1.1 글리프 배치 (총 360개)

```text
초성 섹션: 0~159 (20자 × 8벌)
  ㄱ ㄲ ㄴ ㄷ ㄸ ㄹ ㅁ ㅂ ㅃ ㅅ ㅆ ㅇ ㅈ ㅉ ㅊ ㅋ ㅌ ㅍ ㅎ (19자, 맨 앞은 비어있음)
  
중성 섹션: 160~247 (22자 × 4벌)
  ㅏ ㅐ ㅑ ㅒ ㅓ ㅔ ㅕ ㅖ ㅗ ㅘ ㅙ ㅚ ㅛ ㅜ ㅝ ㅞ ㅟ ㅠ ㅡ ㅢ ㅣ (21자, 맨 앞은 비어있음)
  
종성 섹션: 248~359 (28자 × 4벌)
  ㄱ ㄲ ㄳ ㄴ ㄵ ㄶ ㄷ ㄹ ㄺ ㄻ ㄼ ㄽ ㄾ ㄿ ㅀ ㅁ ㅂ ㅄ ㅅ ㅆ ㅇ ㅈ ㅊ ㅋ ㅌ ㅍ ㅎ (27자, 맨 앞은 비어있음)
```

### 1.2 글리프 크기
- **크기**: 16×16 픽셀
- **용량**: 32바이트/글자 (16행 × 2바이트/행)


### 1.3 폰트 파일 구성
**총 11,520바이트**

| 구분 | 바이트 범위 | 크기 | 구성 |
|------|------------|------|------|
| 초성 8벌 | 0 ~ 5,119 | 5,120 바이트 | 20문자 × 8벌 × 32바이트 |
| 중성 4벌 | 5,120 ~ 7,935 | 2,816 바이트 | 22문자 × 4벌 × 32바이트 |
| 종성 4벌 | 7,936 ~ 11,519 | 3,584 바이트 | 28문자 × 4벌 × 32바이트 |

---

## 2. 벌식 (Bul System)

조합 상황에 따라 다른 형태의 자모를 사용하는 시스템입니다.

### 2.1 벌식 개요
- **초성**: 8벌 (중성 타입, 받침 유무에 따라)
- **중성**: 4벌 (초성 타입, 받침 유무에 따라)
- **종성**: 4벌 (중성 타입에 따라)



### 2.2 조합형 한글 코드 구조

조합형 한글은 **2바이트 코드**로 한글 1자를 표시합니다.

**비트 구성**: `[1비트: 한글/영문 구분][5비트: 초성][5비트: 중성][5비트: 종성]`

#### 조합형 코드표

| 비트값 | 초성 | 중성 | 종성 |
|--------|------|------|------|
| 00000 | - | - | - |
| 00001 | <채움> | - | <채움> |
| 00010 | ㄱ | <채움> | ㄱ |
| 00011 | ㄲ | ㅏ | ㄲ |
| 00100 | ㄴ | ㅐ | ㄳ |
| 00101 | ㄷ | ㅑ | ㄴ |
| 00110 | ㄸ | ㅒ | ㄵ |
| 00111 | ㄹ | ㅓ | ㄶ |
| 01000 | ㅁ | - | ㄷ |
| 01001 | ㅂ | - | ㄹ |
| 01010 | ㅃ | ㅔ | ㄺ |
| 01011 | ㅅ | ㅕ | ㄻ |
| 01100 | ㅆ | ㅖ | ㄼ |
| 01101 | ㅇ | ㅗ | ㄽ |
| 01110 | ㅈ | ㅘ | ㄾ |
| 01111 | ㅉ | ㅙ | ㄿ |
| 10000 | ㅊ | - | ㅀ |
| 10001 | ㅋ | - | ㅁ |
| 10010 | ㅌ | ㅚ | - |
| 10011 | ㅍ | ㅛ | ㅂ |
| 10100 | ㅎ | ㅜ | ㅄ |
| 10101 | - | ㅝ | ㅅ |
| 10110 | - | ㅞ | ㅆ |
| 10111 | - | ㅟ | ㅇ |
| 11000 | - | - | ㅈ |
| 11001 | - | - | ㅊ |
| 11010 | - | ㅠ | ㅋ |
| 11011 | - | ㅡ | ㅌ |
| 11100 | - | ㅢ | ㅍ |
| 11101 | - | ㅣ | ㅎ |
| 11110 | - | - | - |
| 11111 | - | - | - |

### 2.3 벌 선택 규칙

#### ✅ 초성 벌 (8벌)

초성의 벌은 **중성의 종류와 받침(종성) 유무**에 따라 결정됩니다.

**받침이 없을 경우**:
- **1벌**: ㅏ, ㅐ, ㅑ, ㅒ, ㅓ, ㅔ, ㅕ, ㅖ, ㅣ
- **2벌**: ㅗ, ㅛ, ㅡ
- **3벌**: ㅜ, ㅠ
- **4벌**: ㅘ, ㅙ, ㅚ, ㅢ
- **5벌**: ㅝ, ㅞ, ㅟ

**받침이 있을 경우**:
- **6벌**: ㅏ, ㅐ, ㅑ, ㅒ, ㅓ, ㅔ, ㅕ, ㅖ, ㅣ
- **7벌**: ㅗ, ㅛ, ㅜ, ㅠ, ㅡ
- **8벌**: ㅘ, ㅙ, ㅚ, ㅢ, ㅝ, ㅞ, ㅟ

#### ✅ 중성 벌 (4벌)

중성의 벌은 **초성의 종류와 받침(종성) 유무**에 따라 결정됩니다.

- **1벌**: 받침 없음 + 초성이 'ㄱ' 또는 'ㅋ'
- **2벌**: 받침 없음 + 초성이 'ㄱ, ㅋ' 이외
- **3벌**: 받침 있음 + 초성이 'ㄱ' 또는 'ㅋ'
- **4벌**: 받침 있음 + 초성이 'ㄱ, ㅋ' 이외

#### ✅ 종성 벌 (4벌)

종성의 벌은 **중성의 종류**에 따라 결정됩니다.

- **1벌**: ㅏ, ㅑ, ㅘ
- **2벌**: ㅓ, ㅕ, ㅚ, ㅝ, ㅟ, ㅢ, ㅣ
- **3벌**: ㅐ, ㅒ, ㅔ, ㅖ, ㅙ, ㅞ
- **4벌**: ㅗ, ㅛ, ㅜ, ㅠ, ㅡ

---

## 3. 조합형 한글 변환 과정

### 3.1 초성/중성/종성 분리

조합형 한글 2바이트 코드에서 초성/중성/종성을 추출합니다.

**비트 구조**:
- 첫 번째 비트 (bit 0): 한글(1) / 영문(0) 구분
- 비트 1~5: 초성
- 비트 6~10: 중성
- 비트 11~15: 종성

**분리 코드 예시**:
```cpp
bool extract_hangul_components(unsigned char byte1, unsigned char byte2,
                                unsigned char &cho,
                                unsigned char &jung,
                                unsigned char &jong) {
    cho = (byte1 >> 2) & 0b00011111;
    jung = ((byte1 << 3) & 0b00011000) | ((byte2 >> 5) & 0b00000111);
    jong = byte2 & 0b00011111;
    
    if ((byte1 & 0b10000000) == 0) {
        return true;  // 영문
    } else {
        return false; // 한글
    }
}


```

### 3.2 벌 수 계산

초성/중성/종성에 따른 벌 수를 계산합니다.

**벌 수 계산 코드 예시**:
```cpp
if (jong == 0) {
    // 받침이 없는 경우
    cho_bul = cho_table[jung];
    
    if (cho == 1 || cho == 24) {  // ㄱ, ㅋ
        jung_bul = 0;
    } else {
        jung_bul = 1;
    }
    
    jong_bul = 0;
} else {
    // 받침이 있는 경우
    cho_bul = cho_table[jung];
    
    if (cho == 1 || cho == 24) {  // ㄱ, ㅋ
        jung_bul = 2;
    } else {
        jung_bul = 3;
    }
    
    jong_bul = jong_table[jung];
}
```

### 3.3 폰트 데이터 위치 찾기

벌 수를 기반으로 폰트 파일에서 실제 글리프 데이터의 위치를 계산합니다.

```cpp
// 초성 인덱스 (20자 × 벌 수)
cho_index = cho_bul * 20 + cho - 1;

// 중성 인덱스 (22자 × 벌 수 + 오프셋 160)
jung_index = 160 + jung_bul * 22 + jung - 2;

// 종성 인덱스 (28자 × 벌 수 + 오프셋 248)
jong_index = 248 + jong_bul * 28 + jong - 1;

---

## 4. 아두이노에서 UTF-8 한글 출력하기

아두이노는 **UTF-8 인코딩**을 사용하므로, UTF-8 → 유니코드 → 조합형 코드 변환 과정이 필요합니다.

### 4.1 UTF-8 → 유니코드 변환

UTF-8의 한글은 3바이트로 인코딩됩니다: `1110xxxx 10xxxxxx 10xxxxxx`

**유니코드 변환 코드**:
```cpp
unsigned int utf8_to_unicode(unsigned char byte1, unsigned char byte2, unsigned char byte3) {
    unsigned int unicode = 0;
    unicode = ((byte1 & 0b00001111) << 12) | 
              ((byte2 & 0b00111111) << 6) | 
              (byte3 & 0b00111111);
    return unicode;
}
```

### 4.2 유니코드 → 초성/중성/종성 분리

한글 유니코드는 완성형이므로 수식을 통해 초성/중성/종성을 분리할 수 있습니다.

**유니코드 한글 공식**: `유니코드 = (((초성 × 21) + 중성) × 28) + 종성 + 0xAC00`

**역변환 코드**:
```cpp
unsigned int val = utf16 - 0xAC00;
unsigned char jong = val % 28;
unsigned char jung = (val % (28 * 21)) / 28;
unsigned char cho = val / (28 * 21);
```

### 4.3 변환 테이블

유니코드에서 추출한 초성/중성/종성 인덱스를 조합형 코드 인덱스로 변환합니다.

```cpp
// 초성 변환 테이블 (19자)
const unsigned short cho_rdix[] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};

// 중성 변환 테이블 (21자)
// ㅏ ㅐ ㅑ ㅒ ㅓ ㅔ ㅕ ㅖ ㅗ ㅘ ㅙ ㅚ ㅛ ㅜ ㅝ ㅞ ㅟ ㅠ ㅡ ㅢ ㅣ
const unsigned short jung_rdix[] = {3, 4, 5, 6, 7, 10, 11, 12, 13, 14, 15, 18, 19, 20, 21, 22, 23, 26, 27, 28, 29};

// 종성 변환 테이블 (28자)
// <채움> ㄱ ㄲ ㄳ ㄴ ㄵ ㄶ ㄷ ㄹ ㄺ ㄻ ㄼ ㄽ ㄾ ㄿ ㅀ ㅁ ㅂ ㅄ ㅅ ㅆ ㅇ ㅈ ㅊ ㅋ ㅌ ㅍ ㅎ
const unsigned short jong_rdix[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29};
```

### 4.4 UTF-8 한글 출력 함수

모든 변환 과정을 통합한 UTF-8 한글 출력 함수입니다. 

```cpp
void print_hangul_utf8(int x, int y, 
                       unsigned char byte1, 
                       unsigned char byte2, 
                       unsigned char byte3, 
                       uint16_t color) {
    // UTF-8 → 유니코드 변환
    unsigned int utf16 = (byte1 & 0b00001111) << 12 | 
                         (byte2 & 0b00111111) << 6 | 
                         (byte3 & 0b00111111);
    
    // 유니코드 → 초성/중성/종성 분리
    unsigned int val = utf16 - 0xAC00;
    unsigned char jong = val % 28;
    unsigned char jung = (val % (28 * 21)) / 28;
    unsigned char cho = val / (28 * 21);
    
    // 변환 테이블로 조합형 인덱스로 변환
    cho = cho_rdix[cho];
    jung = jung_rdix[jung];
    jong = jong_rdix[jong];
    
    // 한글 출력
    print_hangul(x, y, cho, jung, jong, color);
}
```

---

## 5. 영문 폰트 출력하기

### 5.1 영문 폰트 구조
- **파일 크기**: 4,096바이트
- **글자당 크기**: 16바이트
- **총 글자 수**: 256자 (ASCII 코드 전체)
- **글자 크기**: 8×16 픽셀

---

## 6. 한글-영문 혼합 문자열 출력

### 6.1 UTF-8 문자 바이트 수 판별

UTF-8에서 문자의 바이트 수는 첫 바이트의 비트 패턴으로 구분합니다.

| 첫 바이트 패턴 | 바이트 수 | 설명 |
|---------------|----------|------|
| `0xxxxxxx` | 1바이트 | ASCII (영문, 숫자, 기호) |
| `110xxxxx` | 2바이트 | 라틴 확장 문자 |
| `1110xxxx` | 3바이트 | 한글, 한자, 일본어 등 |
| `11110xxx` | 4바이트 | 이모지 등 |
| `111110xx` | 5바이트 | (거의 사용 안 됨) |
| `1111110x` | 6바이트 | (거의 사용 안 됨) |

### 6.2 혼합 문자열 출력 함수

한글과 영문이 혼합된 문자열을 출력하는 함수입니다.

```cpp
void print_string(int x, int y, char *str, uint16_t color) {
    int pos_x = x;
    int idx = 0;
    int len = strlen(str);
    
    while (idx < len) {
        int bytes = get_char_bytes(str + idx);
        
        if (bytes == 1) {
            // 영문 (1바이트)
            draw_font_eng(pos_x, y, str[idx], color);
            pos_x += 8;  // 영문 폰트 너비
            idx += 1;
        } else if (bytes == 3) {
            // 한글 (3바이트)
            print_hangul_utf8(pos_x, y, str[idx], str[idx+1], str[idx+2], color);
            pos_x += 16;  // 한글 폰트 너비
            idx += 3;
        } else {
            // 기타 문자는 건너뛰기
            idx += bytes;
        }
    }
}
```

### 6.3 문자 바이트 수 판별 함수

```cpp
int get_char_bytes(const char *str) {
    unsigned char byte = (unsigned char)str[0];
    
    if ((byte & 0b10000000) == 0) {
        return 1;  // 0xxxxxxx
    } else if ((byte & 0b11100000) == 0b11000000) {
        return 2;  // 110xxxxx
    } else if ((byte & 0b11110000) == 0b11100000) {
        return 3;  // 1110xxxx
    } else if ((byte & 0b11111000) == 0b11110000) {
        return 4;  // 11110xxx
    } else if ((byte & 0b11111100) == 0b11111100) {
        return 5;  // 111110xx
    } else if ((byte & 0b11111110) == 0b11111110) {
        return 6;  // 1111110x
    }
    
    return 1;  // 기본값
}

```

---

## 7. 요약

### 변환 프로세스
1. **UTF-8 입력** → UTF-8 바이트 스트림 입력
2. **문자 타입 판별** → 1바이트(영문) / 3바이트(한글) 구분
3. **유니코드 변환** → UTF-8 → 유니코드 (한글의 경우)
4. **초성/중성/종성 분리** → 유니코드 수식으로 분리
5. **조합형 인덱스 변환** → 변환 테이블 적용
6. **벌 수 계산** → 조합 규칙에 따라 벌 선택
7. **폰트 데이터 위치 계산** → 파일 오프셋 계산
8. **글리프 렌더링** → 비트맵 데이터 출력

### 주요 데이터
- **초성**: 19자 × 8벌 = 160글자 (5,120바이트)
- **중성**: 21자 × 4벌 = 88글자 (2,816바이트)
- **종성**: 27자 × 4범 = 112글자 (3,584바이트)
- **영문**: 256자 (4,096바이트)

### 폰트 파일 크기
- **한글 폰트**: 11,520바이트 (`.han`)
- **영문 폰트**: 4,096바이트 (`.eng`)

---

**참고**: 이 문서는 EasyView 조합형 한글 폰트의 구조와 Arduino/ESP32에서의 활용 방법을 설명합니다.
