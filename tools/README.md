# 한글 폰트 변환 도구

EasyView 한글 폰트 파일(`.han`)을 Arduino/ESP32용 C 헤더 파일(`.h`)로 변환하는 도구입니다.

## 파일 구성

- `han_font_converter.py` - 한글 폰트 변환기 (`.han` → `.h`)
- `test_hangul_font.py` - 폰트 테스트 및 시각화 도구
- `requirements.txt` - Python 의존성 패키지

## 설치

```powershell
cd tools
pip install -r requirements.txt
```

## 사용 방법

### 1. 폰트 변환 (.han → .h)

**모든 폰트 변환:**
```powershell
python han_font_converter.py
```

**특정 디렉토리 지정:**
```powershell
python han_font_converter.py "경로\Font" "경로\output"
```

**출력:**
- 변환된 `.h` 파일은 `AimHangul/fonts/` 디렉토리에 저장됩니다.
- 각 파일은 Arduino에서 바로 사용 가능한 형식입니다.

### 2. 폰트 테스트

**헤더 파일 테스트:**
```powershell
python test_hangul_font.py "../AimHangul/fonts/H01.h" --text "한글테스트"
```

**원본 .han 파일 테스트:**
```powershell
python test_hangul_font.py "../한글 디스플레이 관련자료/EasyView-3.0.b2/Font/H01.han" --text "안녕하세요"
```

**모든 글리프 시각화:**
```powershell
python test_hangul_font.py "../AimHangul/fonts/H01.h" --show-all --output "glyphs.png"
```

**옵션:**
- `--text` : 테스트할 한글 텍스트 (기본값: "안녕하세요")
- `--output` : 결과 이미지 파일명
- `--show-all` : 모든 글리프를 격자로 표시

## 폰트 구조

### 글리프 배치 (총 360개)

```
초성 섹션: 0~159 (20자 × 8벌)
  ㄱ ㄲ ㄴ ㄷ ㄸ ㄹ ㅁ ㅂ ㅃ ㅅ ㅆ ㅇ ㅈ ㅉ ㅊ ㅋ ㅌ ㅍ ㅎ (19자)
  
중성 섹션: 160~247 (22자 × 4벌)
  ㅏ ㅐ ㅑ ㅒ ㅓ ㅔ ㅕ ㅖ ㅗ ㅘ ㅙ ㅚ ㅛ ㅜ ㅝ ㅞ ㅟ ㅠ ㅡ ㅢ ㅣ (21자)
  
종성 섹션: 248~359 (28자 × 4벌)
  ㄱ ㄲ ㄳ ㄴ ㄵ ㄶ ㄷ ㄹ ㄺ ㄻ ㄼ ㄽ ㄾ ㄿ ㅀ ㅁ ㅂ ㅄ ㅅ ㅆ ㅇ ㅈ ㅊ ㅋ ㅌ ㅍ ㅎ (27자)
```

### 글리프 크기
- 16×16 픽셀
- 32바이트/글자 (16행 × 2바이트/행)
- MSB first 비트 순서

### 벌식 (Bul System)
조합 상황에 따라 다른 형태의 자모를 사용하는 시스템:
- 초성: 8벌 (중성 타입, 받침 유무에 따라)
- 중성: 4벌 (받침 유무에 따라)
- 종성: 4벌 (중성 타입에 따라)

## 한글 렌더링 과정

### 1. UTF-8 → 유니코드 변환
```
한글 UTF-8: 3바이트 (0xE0~0xEF 0x80~0xBF 0x80~0xBF)
→ UTF-16 코드포인트 (0xAC00~0xD7A3)
```

### 2. 초성/중성/종성 분해
```python
val = code - 0xAC00
jong = val % 28
jung = (val // 28) % 21
cho = val // (28 * 21)
```

### 3. 리맵핑
```python
cho_mapped = cho_ridx[cho]
jung_mapped = jung_ridx[jung]
jong_mapped = jong_ridx[jong]
```

### 4. 벌 선택
조합형 한글은 2byte 코드로 한글 1자를 표시한다
 아스키 코드의 경우 1바이트가 영문 1글자를 표시하지만
한글은 2바이트를 사용하여 초기 1비트는 한글인지 영문인지 구분하는 코드로 사용하고
이후 5비트가 초성, 이후 5비트가 중성, 다음 5비트가 종성으로 총 16비트 구성이다. 

각 값에 대한 조합형 코드의 문자는 다음과 같다. 
비트값 / 초성 / 중성 / 종성
00000 / / /
00001 / <채움> / / <채움>
00010 / ㄱ / <채움> / ㄱ
00011 / ㄲ / ㅏ /ㄲ


00000 /  /  / 
00001 / <채움> /  / <채움>
00010 / ㄱ / <채움> / ㄱ
00011 / ㄲ / ㅏ / ㄲ
00100 / ㄴ / ㅐ / ㄳ
00101 / ㄷ / ㅑ / ㄴ
00110 / ㄸ / ㅒ / ㄵ
00111 / ㄹ / ㅓ / ㄶ
01000 / ㅁ /   / ㄷ
01001 / ㅂ /  / ㄹ
01010 / ㅃ / ㅔ / ㄺ
01011 / ㅅ / ㅕ / ㄻ
01100 / ㅆ / ㅖ / ㄼ
01101 / ㅇ / ㅗ / ㄽ
01110 / ㅈ / ㅘ / ㄾ
01111 / ㅉ / ㅙ / ㄿ
10000 / ㅊ /   / ㅀ
10001 / ㅋ /  / ㅁ
10010 / ㅌ / ㅚ / 
10011 / ㅍ / ㅛ / ㅂ
10100 / ㅎ / ㅜ / ㅄ
10101 / / ㅝ / ㅅ
10110 / / ㅞ / ㅆ
10111 / / ㅟ / ㅇ
11000 / / / ㅈ
11001 / / / ㅊ
11010 / / ㅠ  / ㅋ
11011 / / ㅡ / ㅌ
11100 / / ㅢ / ㅍ
11101 / / ㅣ / ㅎ
11110 / / /
11111 / / /

- 폰트파일의 구성 분석
총 11520바이트
초성 8벌은 20문자*8벌 = 160글자 이며 160자 *32바이트 = 5120 바이트
중성 4벌은 2816바이트
종성4벌은 3584바이트

따라서 0~5119위치의 5120바이트는 초성 8벌이 정의되어 있고
이후 5120-7935의 2816바이트는 중성 4벌
이후 7936-11519 의 3584는 종성 4벌에 대해 정의되어 있다

초성 중성 종성은 글자에 따라 모양이 달라 종류가 나뉘어 있으며 이렇게 모양을 구분해 둔 것을 '벌' 이라 한다

각 '벌'의 구별
✅ 초성
초성 1벌 : 받침없는 ㅏ,ㅐ,ㅑ,ㅒ,ㅓ,ㅔ,ㅕ,ㅖ,ㅣ와 결합
초성 2벌 : 받침없는 ㅗ,ㅛ,ㅡ
초성 3벌 : 받침없는 ㅜ,ㅠ
초성 4벌 : 받침없는 ㅘ,ㅙ,ㅚ,ㅢ
초성 5벌 : 받침없는 ㅝ,ㅞ,ㅟ
초성 6벌 : 받침있는 ㅏ,ㅐ,ㅑ,ㅖ,ㅓ,ㅔ,ㅕ,ㅖ,ㅣ 와 결합
초성 7벌 : 받침있는 ㅗ,ㅛ,ㅜ,ㅠ,ㅡ
초성 8벌 : 받침있는 ㅘ,ㅙ,ㅚ,ㅢ,ㅝ,ㅞ,ㅟ

✅ 중성

중성 1벌 : 받침없는 ㄱ,ㅋ 와 결합
중성 2벌 : 받침없는 ㄱ,ㅋ 이외의 자음
중성 3벌 : 받침있는 ㄱ,ㅋ 와 결합
중성 4벌 : 받침있는 ㄱ,ㅋ 이외의 자음

✅ 종성

종성 1벌 : 중성 ㅏ,ㅑ,ㅘ 와 결합
종성 2벌 : 중성 ㅓ,ㅕ,ㅚ,ㅝ,ㅟ,ㅢ,ㅣ
종성 3벌 : 중성 ㅐ,ㅒ,ㅔ,ㅖ,ㅙ,ㅞ
종성 4벌 : 중성 ㅗ,ㅛ,ㅜ,ㅠ,ㅡ

-초성의 '벌'수 결정방법
중성의 종류에 따라 초성의 벌수가 결정된다. 

종성이 없을 경우 
ㅏ,ㅐ,ㅑ,ㅒ,ㅓ,ㅔ,ㅕ,ㅖ,ㅣ 1벌
ㅗ ,ㅛ,ㅡ 2벌
ㅜ, ㅠ 3벌
ㅘ,ㅙ,ㅚ,ㅢ 4벌
ㅝ,ㅞ,ㅟ 5벌

종성이 있을 경우 
ㅏ,ㅐ,ㅑ,ㅒ,ㅓ,ㅔ,ㅕ,ㅖ, ㅣ 6벌
ㅗ,ㅛ,ㅜ,ㅠ,ㅡ 7벌
ㅘ,ㅙ,ㅚ,ㅝ,ㅞ,ㅟ,ㅢ 8벌

-중성의 벌 수 결정
종성이 없을 경우 초성이 'ㄱ'이거나 'ㅋ'인 경우 1벌, 아닌 경우 2벌
종성이 있을 경우 초성이 'ㄱ'이거나 'ㅋ'인 경우 3벌, 아닌 경우 4벌

-종성의 벌 수 결정
ㅏ,ㅑ,ㅘ 1벌
ㅓ,ㅕ,ㅚ,ㅝ,ㅟ,ㅢ,ㅣ 2벌
ㅑ,ㅒ,ㅔ,ㅖ,ㅙ,ㅞ 3벌
ㅗ,ㅛ,ㅜ,ㅠ,ㅡ 4벌


### 5. 글리프 인덱스 계산
```python
cho_idx = cho_bul * 20 + (cho_mapped - 1)
jung_idx = 160 + jung_bul * 22 + (jung_mapped - 2)
jong_idx = 248 + jong_bul * 28 + (jong_mapped - 1)  # jong > 0인 경우만
```

### 6. 합성 렌더링
```
초성 글리프 | 중성 글리프 | 종성 글리프 → 최종 한글
```

## 출력 예시

### 변환 출력
```
📁 142개의 한글 폰트 파일 발견

✓ 변환 완료: ..\AimHangul\fonts\H01.h
  - 총 360개 글리프
  - 파일 크기: 11520 바이트
...
✅ 변환 완료! 출력 디렉토리: ..\AimHangul\fonts
```

### 테스트 출력


## 생성된 헤더 파일 사용법

```cpp
#include "H01.h"

// 폰트 데이터 접근
const uint8_t* font_ptr = H01_font;

// 특정 글리프 읽기 (예: 인덱스 10)
int glyph_index = 10;
int offset = glyph_index * 32;

for (int row = 0; row < 16; row++) {
    uint8_t b0 = pgm_read_byte(&font_ptr[offset + row * 2]);
    uint8_t b1 = pgm_read_byte(&font_ptr[offset + row * 2 + 1]);
    
    // 비트 전개하여 픽셀 그리기
    for (int k = 0; k < 8; k++) {
        if (b0 & (0x80 >> k)) setPixel(x + k, y + row);
        if (b1 & (0x80 >> k)) setPixel(x + 8 + k, y + row);
    }
}
```
